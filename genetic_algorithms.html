<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <link rel="shortcut icon" href="./images/logo.ico">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Finch by dtnewman</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <a href="./index.html"><img src="./images/logo.png"  width="300" height="150"></a>
        <h2>A library for local search and stochastic optimization in Go.</h2>
        <a href="https://github.com/dtnewman/finch" class="button"><small>View project on</small>GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h1>
<a name="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages"><span class="octicon octicon-link"></span></a>Genetic Algorithms</h1>

<p>Genetic algorithms are a form of local search that mimic&mdash;and are inspired by&mdash;the process of natural selection. The algorithm begins by generating a series of candidates in a population of size <i>n</i>. You can seed this population with pre-made candidates, but it is more common to just generate random candidates so that you cover a diverse range of options within the search space. The representation of each individual solution within the population is often referred to as a <b>chromosome</b>. The individual values of each chromosome are sometimes referred to as <b>genes</b>.</p>

<p>Once you have setup an initial population, you iterate the algorithm until a stopping condition is met. At each iteration, you generate <i>n</i> "children" to fill the next generation. Children are generated through a two part process:</p>
<ol>
	<li><b>Crossover</b>- The process of taking two parent chromosomes and combining them together to produce a child</li>
	<li><b>Mutation</b>- The child generated through crossover is randomly perturbed to generate a "mutated" individual</li>
</ol>

Let's go into a bit more depth on each of these processes. 

<h3>Crossover</h3>
<p>There are several variants of crossover (also known as <i>recombination</i>), but they all involve mixing two parent chromosomes together to generate offspring. Typically, these parents are selected probabilistically from the population, with higher fitness individuals in the population having a higher chance of being selected to breed each child. As with many real life examples of natural selection, high fitness individuals are likely to have multiple children in the next generation, while low fitness individuals may not get a chance to breed at all. In the <i>finch</i> implementation of this algorithm, individuals are selected with a probability based on their position in an ordered pool, not based on actual fitness values.</p> 

<p>In <b>one-point crossover</b>, a single spot is randomly picked to slice both parent chromosomes. The child is then generated using one side of the slice from the first parent and the other side of the slice from the second parent. The figure below shows an example of this:</p>

<img src="./images/crossover1.jpeg">

<p>In <b>uniform crossover</b>, you go through each chromosome and then randomly select from each of the parents for each individual gene. The figure below shows this process:</p>

<img src="./images/crossover2.jpeg">

<p>Occasionally, problems are represented in ways that makes crossover a difficult process. For example, if you are optimizing the travelling salesman problem, then your representation of a chromosome might be an ordering of cities to visit. In this case, <b>ordered crossover</b> is necessary. In this process, we select a subset from the first parent and add that subset to our child. Then, we add genes that are not yet in the child using the second parent's order. The figure below shows this two step process:</p>

<img src="./images/crossover3.jpeg">

<h3>Mutation</h3>

<p>In the most commonly used mutatation algorithm, each gene in the child is iterated through and at each iteration, a random number <i>r</i> (where 0 < <i>r</i> < 1.0) is generated. If <i>r</i> is less than the user provided <b>mutation rate</b>, then that gene is randomly changed to another valid value. However, this doesn't always work. As with crossover, you might have cases such as the travelling salesman problem where each gene must be unique. If that is the case, then <b>swap mutation</b> can be used, whereby two genes are simply switched with each other, as in the figure below: </p> 

<img src="./images/swap_mutation.jpeg">

<h3>Additional notes</h3>

<p>Generally, crossover is the main methodology used for improving solutions in genetic algorithms, with mutations used to keep the population pool diverse and to prevent the algorithm from getting stuck at local minima for too long, although this is subject to debate since some implementations of the algorithm rely heavily on mutations to improve the fitness function.</p>

<p>One issue with genetic algorithms is that the best solutions are lost from one generation to the next. To prevent this, sometimes an <b>elitism strategy</b> is used, where a specified number of the top solutions will always be cloned into the next generation without crossover or mutation. Of course, doing this often causes the population to become less diverse and therefore more likely to get stuck on local maxima, but a modest elitism strategy often leads to better overall solutions for many problems.</p> 

<h3>Finch implementation</h3>
<p>The <i>finch</i> implementation of genetic algorithms allows you to pass in crossover and mutation algorithms. It also allows you to specify population size and the number of elite individuals to pass from each generation to the next. The stopping condition on this algorithm happens when a user specified number of iterations have passed. </p>
<p>The <i>finch</i> function for genetic algorithms has the following signature:</p>
<pre><code>func genetic_algorithm(population_size int, evaluate func([]int) float64,
	create_random func() []int , mutate func([]int, float64) []int,
	crossover func([]int,[]int) []int, mutation_rate float64, 
	num_iterations int, num_elite int)
</code></pre>
<p>The function takes in the following parameters:</p>
<ul>
  <li><b>population_size</b> - The number of individuals in the population at each generation</li>
  <li><b>evaluate</b> - A function that you must construct and pass in which takes a state of type int[] as a parameter and returns a fitness score for the given state of type float64</li>
  <li><b>create_random</b> - A function that you must construct and pass in which takes no parameters and returns a 1-dimensional array of type int[] containing a random starting state for your problem</li>
  <li><b>mutate</b> - A function that you must construct and pass in which takes a state of type int[] as a parameter and returns a "mutated" array of type int[]</li>
  <li><b>crossover</b> - A function that you must construct and pass in which takes two states of type int[] as parameters and returns a child of type int[] which is a result of the crossover algorithm in this function</li>
  <li><b>mutation_rate</b> - A value between 0.0 and 1.0 for the mutation rate. Typical values are between 0.01 and 0.10 </li>
  <li><b>num_iterations</b> - The number of iterations to run the algorithm for </li>
  <li><b>num_elite</b> - The number of elite individuals that should automatically pass from one generation to the next without mutation or crossover </li>
</ul>
<p>The function returns two values:<p>
<ul>
  <li>The state found with the highest fitness score (type []int)</li>
  <li>The fitness score at this state (type float64)</li>
</ul>
<p><a href="./index.html">Return to home page</a></p>
        </section>

        <aside id="sidebar">
          <a href="./hill_climb.html" class="button">
            Hill climbing
          </a>
          <a href="./beam_search.html" class="button">
            Beam search
          </a>
          <a href="./tabu_search.html" class="button">
            Tabu search
          </a>
          <a href="./simulated_annealing.html" class="button">
            Simulated annealing
          </a>          
          <a href="./genetic_algorithms.html" class="button">
            Genetic algorithms
          </a>       

          <p class="repo-owner"><a href="https://github.com/dtnewman/finch"></a>This website is maintained by <a href="https://github.com/dtnewman">dtnewman</a>.</p>

          <!--<p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>-->
        </aside>
      </div>
    </div>

  
  </body>
</html>
