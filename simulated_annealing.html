<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <link rel="shortcut icon" href="./images/logo.ico">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Finch by dtnewman</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <a href="./index.html"><img src="./images/logo.png"  width="300" height="150"></a>
        <h2>A library for local search and stochastic optimization in Go.</h2>
        <a href="https://github.com/dtnewman/finch" class="button"><small>View project on</small>GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h1>
<a name="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages"><span class="octicon octicon-link"></span></a>Simulated Annealing</h1>

<p>Simulated annealing is a very popular technique for global optimization. The method was adapted from the Metropolis-Hastings algorithm. The inspiration for the algorithm was the process of annealing in materials science, whereby materials and heated and cooled in a controlled way in order to reduce defects.</p>

<p> In simulated annealing, we start out with a an initial sate and then keep iterating, making small changes to the state each time. If the changes improve the objective function, then they are always accepted. If not, then we may <i>still</i> accept them with some probability. Typically, this process is repeated until a stopping condition is met.</p>

<p> The acceptance probability function <code>P(e,e',T)</code> (where <i>e</i> and <i>e'</i> are the old and new energies respectively and <i>T</i> is the temperature) is usually defined as 1 if <i>e'</i> < <i>e</i> and <i>exp(-(e'-e)/T)</i> otherwise.</p>

<p> Below is pseudocode for simulated annealing:</p>

<pre><code>$ // Return a state that is an approximation of the global maximum
$ function <b>simulated annealing</b>(<i>initial_state</i>, <i>init_temperature</i>):
$ &nbsp;&nbsp;&nbsp;&nbsp;<i>best_state</i> &#8592 <i>initial_state</i>
$ &nbsp;&nbsp;&nbsp;&nbsp;<i>current_state</i> &#8592 <i>initial_state</i>
$ &nbsp;&nbsp;&nbsp;&nbsp;<i>current_fitness</i> &#8592 fitness(<i>current_state</i>)
$ &nbsp;&nbsp;&nbsp;&nbsp;<i>temperature</i> &#8592 <i>init_temperature</i>
$ &nbsp;&nbsp;&nbsp;&nbsp;<b>loop do</b>
$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set <i>n</i> based on <i>temperature</i>
$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>proposal_state</i> &#8592 make_n_changes(<i>current_state</i>,<i>n</i>)
$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>proposal_fitness</i> &#8592 fitness(<i>proposal_state</i>)
$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If the new state is better than the current state, accept it
$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>If</b> proposal_fitness > current_fitness:
$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>current_state</i> &#8592 <i>proposal_state</i>
$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>If</b> <i>proposal_fitness</i> > fitness(<i>best_state</i>):
$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>best_state</i> &#8592 <i>proposal_state</i>
$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If the new state is not better than the current state, 
$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// still accept with some probability
$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>ElseIf</b> P(<i>current_fitness</i>, <i>proposal_fitness</i>, <i>temperature</i>) > random()):
$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>current_state</i> &#8592 <i>proposal_state</i>
$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>temperature</i> &#8592 Update(<i>temperature</i>)
$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check stopping condition. If met, return <i>best_state</i>
</code></pre>

<p>fdsfdsafds</p> 

<p>The <i>finch</i> implementation of simulated has the following signature:</p>
<pre><code>func tabu_search(initial_solution []int, max_num_neighbors int, 
        tabu_list_max_size int, evaluate func([]int) float64, 
        get_neighbors func([]int) [][]int)
</code></pre>
<p>The function takes in the following parameters:</p>
<ul>
  <li><b>initial_solution</b> - An int[] array with an initial solution to seed the algorithm with</li>
  <li><b>max_num_neighbors</b> - The number of neighbors in the total list of neighbors generated at each step to consider. Larger values for this number might yield better results, but take up more processing time.</li>
  <li><b>tabu_list_max_size</b> - The maximum number of states to store in the tabu list. Larger values will give better results, but at the expense of increased processing time and memory usage.</li>
  <li><b>evaluate</b> - A function that you must construct and pass in which takes a solution of type int[] as a parameter and returns a fitness score for the given solution of type float64</li>
  <li><b>get_neighbors</b> - A function that you must construct and pass in which takes a solution of type int[] as a parameter and returns a 2-dimensional array of type int[][] with all neighboring solutions</li>
</ul>
<p>The function returns two values:<p>
<ul>
  <li>The state at the local maximum (type []int)</li>
  <li>The fitness score at the local maximum (type float64)</li>
</ul>

<h2>Random-restart tabu search</h2>
The <i>finch</i> library also contains an algorithm for random-restart tabu search, which is directly analogous to random-restart hill climbing. As with random-restart hill climbing, this algorithm generates <i>k</i> random start states and then runs tabu search on all of those. The function has the following signature:</p>
<pre><code>func random_restart_tabu_search(num_restarts int, max_num_neighbors int, 
        tabu_list_max_size int,evaluate func([]int) float64, 
        create_random func() []int, get_neighbors func([]int) [][]int)
</code></pre>
<p>The function takes in the following parameters:</p>
<ul>
  <li><b>num_restarts</b> - The number of random restarts to run.</li>
  <li><b>max_num_neighbors</b> - The number of neighbors in the total list of neighbors generated at each step to consider. Larger values for this number might yield better results, but take up more processing time.</li>
  <li><b>tabu_list_max_size</b> - The maximum number of states to store in the tabu list. Larger values will give better results, but at the expense of increased processing time and memory usage.</li>
  <li><b>evaluate</b> - A function that you must construct and pass in which takes a solution of type int[] as a parameter and returns a fitness score for the given solution of type float64</li>
  <li><b>create_random</b> - A function that you must construct and pass in which takes no parameters and returns a 1-dimensional array of type int[] containing a random starting solution for your problem</li>
  <li><b>get_neighbors</b> - A function that you must construct and pass in which takes a solution of type int[] as a parameter and returns a 2-dimensional array of type int[][] with all neighboring solutions</li>
</ul>
<p>The function returns two values:<p>
<ul>
  <li>The state at the local maximum (type []int)</li>
  <li>The fitness score at the local maximum (type float64)</li>
</ul>

<p><a href="./index.html">Return to home page</a></p>
        </section>

        <aside id="sidebar">
          <a href="./hill_climb.html" class="button">
            Hill climbing
          </a>
          <a href="./beam_search.html" class="button">
            Beam search
          </a>
          <a href="./tabu_search.html" class="button">
            Tabu search
          </a>
          <a href="./simulated_annealing.html" class="button">
            Simulated annealing
          </a>          
          <a href="./genetic_algorithms.html" class="button">
            Genetic algorithms
          </a>       

          <p class="repo-owner"><a href="https://github.com/dtnewman/finch"></a>This website is maintained by <a href="https://github.com/dtnewman">dtnewman</a>.</p>

          <!--<p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>-->
        </aside>
      </div>
    </div>

  
  </body>
</html>
