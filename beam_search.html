<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <link rel="shortcut icon" href="./images/logo.ico">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Finch by dtnewman</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <a href="./index.html"><img src="./images/logo.png"  width="300" height="150"></a>
        <h2>A library for local search and stochastic optimization in Go.</h2>
        <a href="https://github.com/dtnewman/finch" class="button"><small>View project on</small>GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h1>
<a name="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages"><span class="octicon octicon-link"></span></a>Beam Search</h1>

<p>With hill climbing, we get the advantage of using relatively little memory in most cases since in any iteration, the algorithm only needs to keep track of its current state and that state's immediate neighbors (for determining the next step).</p>
<p>Beam search allows us to start with a collection of <i>k</i> randomly generated states. We keep track of all <i>k</i> "beams" at each step. At every iteration, the algorithm generates a set of neighbors of all <i>k</i> states. Then, it selects the top <i>k</i> successors from the complete list of neighbors and repeats. In pseudocode:</p>
<pre><code>$ // Return a state that is a local maximum
$ function <b>beam_search</b>(problem):
$ &nbsp;&nbsp;&nbsp;&nbsp;<i>k-current-states</i> <-Initialize the problem with <i>k</i> starting states
$ &nbsp;&nbsp;&nbsp;&nbsp;<i>max_value</i> <- -infinity
$ &nbsp;&nbsp;&nbsp;&nbsp;loop do
$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop through each beam in <i>k-current-states</i>
$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add all successors for each beam to <i>neighbors</i>
$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If the maximum fitness value of the states in <i>neighbors</i> <= <i>max_value</i>:
$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Terminate and return member of <i>k-current-states</i> with highest fitness
$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>k-current-states</i> <- top <i>k</i> values in <i>neighbors</i>
</code></pre>

<p>Beam search can be easily confused with random-restart hill climbing. For example, how is beam search with 100 beams different from running hill-climbing with 100 random restarts? The difference is that for random-restart hill climbing, each run of the algorithm is completely independent of the other. For beam search, since the next generation is chosen from the pool of successors to all of the beams, the lowest ranked beams will quickly drop out of the pool. In some cases, this might actually be a bad thing. For a simple example, let's say that your search space looks like the diagram below and that you are using 3 beams, and they happened to fall out in the parts of the search space pointed to by the red arrows:</p>
<img src="./images/beam_search_example.png" border="1">
<p>In this search space, there is a clear global maximum on the left hand side of the diagram. However, in the next generation, it is likely that all three of the candidates might be selected from "children" of the middle beam. If that's the case, then all three solution in that generation will be near the local maximum close to the middle beam, it's unlikely that we'll ever get to the global maximum, which is actually closer to the left beam. Of course, this problem could be solved by adding more beams, thereby increasing the chance of having one that falls out near the global max. In reality though, a search space might have millions of local maxima and increasing the number of threads accordingly might not be a feasible approach due to memory and computational constraints. So we can see that beam search might not work well in all search landscapes. Below is an example of a search landscape where beam search would probably yield good results:</p>
<img src="./images/beam_search_example2.png" border="1">
<p>In this example, there are many local peaks that come close to the global maximum. So even if you don't have any beams that start out near the global maximum (which is at second peak from the right by a close margin), it's likely that you will find a solution whose value is very close to the global maximum. In many optimization problems, being reasonably close to the global optimum is all that counts.</p>

<p>In <i>finch</i>, the beam search algorithm has the following signature:
<pre><code>func beam_search(num_beams int, evaluate func([]int) float64, 
        create_random func() []int, get_neighbors func([]int) [][]int)
</code></pre>
<p>The function takes in the following parameters:</p>
<ul>
  <li><b>num_beams</b> - The number of beams to use</li>
  <li><b>evaluate</b> - A function that you must construct and pass in which takes a solution of type int[] as a parameter and returns a fitness score for the given solution of type float64</li>
  <li><b>create_random</b> - A function that you must construct and pass in which takes no parameters and returns a 1-dimensional array of type int[] containing a random starting solution for your problem</li>
  <li><b>get_neighbors</b> - A function that you must construct and pass in which takes a solution of type int[] as a parameter and returns a 2-dimensional array of type int[][] with all neighboring solutions</li>
</ul>
<p>The function returns two values:<p>
<ul>
  <li>The state at the local maximum (type []int)</li>
  <li>The fitness score at the local maximum (type float64)</li>
</ul>
<h2>Stochastic beam search</h2>
<p>In certain situations, such as was described in relation to the first diagram above, the pool of beams can suffer from a lack of diversity such that all of the beams end up concentrating on one portion of the search space. When this happens, beam search is doing little more that an expensive version of hill climbing. Stochastic beam search helps to alleviate this issue. In this algorithm, which is somewhat similar to stochastic hill climbing, the next generation of beams are chosen randomly, with higher value beams having a higher chance of being chosen.</p>
<p>The <i>finch</i> version of stochastic beam search doesn't take into account actual fitness scores when choosing successors. It only takes into account relative positions. In other words, we rank the pool neighbors from worst to best and then we choose the next pool randomly, with each neighbor having a chance of being chosen that corresponds to its position in this ordered pool, not to its actual fitness value. If you have <i>x</i> beams, then the probability of the beam at position <i>i</i> being chosen for each slot in the next generation is simply:</p>

<img src="./images/stochastic_beam_search_formula.png">

<p>The algorithm also uses an <i>elitism strategy</i> whereby the top member of each generation always gets passed to the next with 100% probability. Finally, unlike standard beam search, the <i>finch</i> implementation of stochastic beam search has a stopping condition that it must show no improvement for a user determined number of iterations before it terminates. Occassionally, the algorithm will go a few iterations without improving, before selecting a better neighbor and then continuing to climb higher. By adding this feature, it helps the algorithm escape local maxima. The functions signature is as follows:</p>
<pre><code>func stochastic_beam_search(num_beams int, max_iterations_no_improvement int, 
        evaluate func([]int) float64, create_random func() []int, 
        get_neighbors func([]int)
</code></pre>
<p>The function takes in the following parameters:</p>
<ul>
  <li><b>num_beams</b> - The number of beams to use</li>
  <li><b>max_iterations_no_improvement</b> - The number of iterations with no improvements before the algorithm terminates</li>
  <li><b>evaluate</b> - A function that you must construct and pass in which takes a solution of type int[] as a parameter and returns a fitness score for the given solution of type float64</li>
  <li><b>create_random</b> - A function that you must construct and pass in which takes no parameters and returns a 1-dimensional array of type int[] containing a random starting solution for your problem</li>
  <li><b>get_neighbors</b> - A function that you must construct and pass in which takes a solution of type int[] as a parameter and returns a 2-dimensional array of type int[][] with all neighboring solutions</li>
</ul>
<p>The function returns two values:<p>
<ul>
  <li>The state at the local maximum (type []int)</li>
  <li>The fitness score at the local maximum (type float64)</li>
</ul>
<p><a href="./index.html">Return to home page</a></p>
        </section>

        <aside id="sidebar">
          <a href="./hill_climb.html" class="button">
            Hill climbing
          </a>
          <a href="./beam_search.html" class="button">
            Beam search
          </a>
          <a href="./tabu_search.html" class="button">
            Tabu search
          </a>
          <a href="./simulated_annealing.html" class="button">
            Simulated annealing
          </a>          
          <a href="./genetic_algorithms.html" class="button">
            Genetic algorithms
          </a>       

          <p class="repo-owner"><a href="https://github.com/dtnewman/finch"></a>This website is maintained by <a href="https://github.com/dtnewman">dtnewman</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>
